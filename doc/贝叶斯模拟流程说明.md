# 基于模拟数据的贝叶斯姿态反演流程说明 (TS差异模型版)

## 1. 概述

本文档旨在详细阐述 `bayesian_solver.py` 脚本所执行的完整模拟与反演流程。该流程遵循了《五维波束游泳状态解算.md》文档中描述的贝叶斯方法（方法三），通过完全基于模拟的数据，端到端地展示了如何从五维波束的TS（目标强度）观测值反向推断出目标的游泳姿态（方向角Yaw, 倾斜角Tilt）。

**此版本模型的核心改进是：采用TS差异作为特征，以消除目标体长（L）变化对反演结果的影响，从而使模型更加鲁棒。**

整个流程的核心思想是：
1.  首先，创建一个“虚拟世界”，即一个能描述“在特定姿态下，我们会看到怎样TS差异值”的**正向模型**。
2.  然后，在这个虚拟世界中进行一次“模拟观测”，得到一组带有随机性的TS差异数据。
3.  最后，使用贝叶斯方法，根据这次“模拟观测”的数据，反向推断目标最可能处于哪种姿态，并评估结果的准确性。

## 2. 核心脚本: `bayesian_solver.py`

此脚本是整个流程的完整代码实现，它整合了数据生成、模型反演和结果可视化三个部分，共分为四个紧密衔接的阶段。

### 2.1 模型构建与数据处理层次

在 `bayesian_solver.py` 脚本中，"模型"的构建和数据的处理经历了两个重要的层次，这对于理解整个贝叶斯反演流程至关重要：

1.  **第一层次：经验TS模型 (Empirical TS Model) - 物理层面的正向模型**
    *   **构建方式**: 这是由 `EmpiricalTSModel` 类负责的。它加载您的真实测量数据 (`TS_interpolated_0p1kHz.nc`)，目前该文件中的数据涵盖了 **-60°到+20°** 的入射角范围。类会从中选择一个目标频率（例如120kHz），通过物理正确的线性域平均方法处理两条鱿鱼的数据，然后构建一个TS-角度的插值函数。
    *   **作用**: 这个插值函数 `empirical_ts_model.get_ts(incidence_angle_deg)` 能够根据任何输入的入射角，返回一个基于您真实测量数据的TS值。它是我们模拟世界中最底层的物理规律，取代了之前简化的 `ts_physical_model`。这个模型本身是**非对称的**。
    *   **输入**: 单个入射角。
    *   **输出**: 对应入射角的单个TS值。

2.  **第二层次：统计查找表 (LUT) - 贝叶斯反演直接使用的数学模型**
    *   **构建方式**: 这是由 `generate_statistical_lut` 函数负责的。它利用第一层次的“经验TS模型”进行大量的蒙特卡洛模拟。在模拟过程中，它会考虑波束不确定性、体长随机化和测量噪声，为每个姿态 `(Yaw, Tilt)` 生成5个模拟的原始TS值。
    *   **数据转换**: 这些模拟的原始TS值（5个）随后被转换为4个**TS差异值**（例如 `TS_N - TS_V`, `TS_S - TS_V` 等）。
    *   **作用**: LUT存储了这些4个TS差异值在每个 `(Yaw, Tilt)` 姿态下的均值和标准差。它是贝叶斯反演算法直接进行似然度计算的依据，是“贝叶斯世界观”中的正向模型。
    *   **输入**: 某个姿态 `(Yaw, Tilt)`。
    *   **输出**: 4个TS差异的统计特性（均值和标准差）。

通过这种分层构建和数据转换（从5个原始TS值 -> 4个TS差异值），脚本实现了：
-   **鲁棒性**: 消除了体长和绝对TS值的干扰。
-   **准确性**: 引入了基于真实数据的精确物理模型。

## 3. 模拟的四个阶段

### 阶段一：构建统计查找表 (LUT) - “正向模型” (基于TS差异)

这是整个研究的基石。我们创建了一个“查找表”（Lookup Table, LUT），它存储了在**每一个可能姿态**下，四个TS差异特征会观测到的TS差异值的**统计特性（均值和标准差）**。

-   **目的**: 预先计算好所有理论可能性，为后续快速查询和概率计算做准备。
-   **核心改进**: 此阶段引入了体长 `L` 的随机性，并计算**TS差异**，以确保LUT对体长L的鲁棒性。
-   **过程**:
    1.  **定义姿态空间**: 脚本首先定义了所有需要计算的姿态。**（重要更新）**为提高精度，目前脚本采用**1度分辨率**：Yaw 从 0° 到 359°（步长1°），Tilt 从 -60° 到 60°（步长1°）。**注意：这会使LUT的生成时间变得非常长！**
    2.  **蒙特卡洛模拟**: 脚本会遍历上述姿态空间中的每一个点 `(Yaw, Tilt)`，并对每个点进行上千次（`MONTE_CARLO_SAMPLES`）的随机模拟。
    3.  **在单次模拟中，脚本会**:
        a.  **随机化体长L**: 从预设范围（`MIN_L_CM` 到 `MAX_L_CM`）中随机抽取一个体长 `L`。
        b.  根据当前姿态 `(Yaw, Tilt)` 计算出5个“理想”的入射角（采用 `[-90°, +90°]` 定义）。
        c.  **引入不确定性**:
            i.  为“理想入射角”叠加上一个随机噪声，模拟声呐波束宽度带来的不确定性 (`BEAM_UNCERTAINTY_STD`)。
            ii. 使用一个包含体长 `L` 参数的 `ts_physical_model` 函数，根据带噪声的入射角和随机体长 `L` 计算出5个“绝对TS值”。
            iii. 为“绝对TS值”再叠加上一个随机噪声，模拟设备本身的测量误差 (`TS_NOISE_STD`)。
        d.  **计算TS差异**: 以垂直波束（Vertical）的TS为参考，计算其他四个水平波束的TS差异（例如 `TS_N - TS_V`, `TS_S - TS_V` 等）。
            *   **重要说明**: 在这一步，体长 `L` 对绝对TS值的影响 `20*log10(L/REF_L_CM)` 会被完美抵消，从而确保TS差异与体长L无关。
    4.  **统计与存储**: 完成上千次模拟后，我们就得到了在当前姿态下，4个TS差异的分布。脚本会计算这4个TS差异的**均值（μ）**和**标准差（σ）**。
-   **输出**:
    -   一个名为 `ts_diff_empirical_lut.nc` 的NetCDF文件。该文件是一个巨大的多维数组，存储了每一个 `(Yaw, Tilt)` 姿态下，4个TS差异特征对应的均值和标准差。
    -   由于此过程计算量巨大，脚本只在第一次运行时生成该文件，后续会直接加载，以节省时间。

### 阶段二：生成“真实”观测数据 (TS差异)

在拥有了描述虚拟世界的“字典”（即LUT）之后，我们需要一次“真实”的观测事件来作为我们反演的目标。

-   **目的**: 创建一组具体的、带有合理随机性的**TS差异观测值**，用于测试我们的反演算法。
-   **过程**:
    1.  我们在脚本中手动指定一个“真实”的姿态，例如 `TRUE_YAW = 45`, `TRUE_TILT = -20`。
    2.  随机抽取一个体长 `L`（模拟真实世界中的未知体长）。
    3.  调用与阶段一**完全相同**的含噪声模型，**只运行一次**，生成5个具体的绝对TS值。
    4.  **计算TS差异**: 将这5个绝对TS值转换为4个TS差异值。
-   **输出**:
    -   一组4个TS差异浮点数，被视为我们从外部设备获得的“实测数据”。

### 阶段三：执行贝叶斯反演 (基于TS差异)

这是算法的核心，我们拿着阶段二的“实测TS差异数据”，去问阶段一的“字典”：我的这组差异数据，最像是从哪个理论姿态产生的？

-   **目的**: 计算在给定“实测TS差异数据”的条件下，每一个候选姿态 `(Yaw, Tilt)` 的**后验概率 (Posterior Probability)**。
-   **过程 (基于贝叶斯公式: `后验 ∝ 似然 × 先验`)**:
    1.  **计算似然度 (Likelihood)**: 脚本遍历LUT中的每一个姿态 `(Yaw, Tilt)`。对于每个姿态，它会：
        a.  从LUT中取出该姿态下4个TS差异特征的均值`μ`和标准差`σ`。
        b.  它假设TS差异的分布是高斯分布，然后计算我们的“实测TS差异值”出现在这个高斯分布中的概率。这个概率就是“似然度”。
        c.  将4个特征的对数似然度相加，得到该姿态下的总对数似然度。
    2.  **定义先验 (Prior)**:
        *   **默认情况 (均匀先验)**: 在默认设置下，我们使用了**均匀先验**，即假设在进行计算前，鱿鱼朝向任何姿态的概率都是完全相等的。这在代码中体现为 `log_prior` 是一个全为0的矩阵。
        *   **（重要更新）引入非均匀先验**: 如果我们有关于目标姿态的先验知识（例如，根据经验我们知道鱿鱼的游泳方向大概率在某个范围内，或者游泳倾角大于某个值），我们可以使用**非均匀先验**来约束模型。在 `batch_inversion_analysis.py` 脚本中，可以通过 `--yaw-prior` 和 `--tilt-prior` 命令行参数来定义一个“硬边界”先验。模型会将所有在指定姿态范围**之外**的区域的先验概率设为0，只在**允许的范围内**寻找最优解。这对于解决模型的模糊性问题（如Tilt符号模糊性）非常有效。
    3.  **计算后验 (Posterior)**: 将“对数似然度”与“对数先验”相加，得到“对数后验概率”。然后通过指数和归一化操作，将其转换为一个覆盖所有姿态的、总和为1的概率图。
-   **输出**:
    -   一个二维数组，即**后验概率分布图**。数组中每个点的值，代表了目标处于该点对应姿态 `(Yaw, Tilt)` 的概率。

### 阶段四：结果可视化与解读 (TS差异模型)

-   **目的**: 将抽象的后验概率数据，以直观的热力图形式展现出来。
-   **过程**:
    1.  脚本使用 `matplotlib` 绘制一个二维热力图，图中颜色越亮，代表该姿态的后验概率越高。
    2.  在图上用红色“+”标记出我们在阶段二设定的“真实姿态”。
    3.  在图上用白色“x”标记出图中概率最高点，即模型“估计的姿态”。
-   **结果解读与“Tilt正负号模糊性”**:
    -   从运行结果看，与之前的模型相比，**Yaw方向上的180度模糊性已得到解决**，模型现在能够准确估计Yaw值。
    -   但是，**Tilt方向上出现了新的模糊性**。模型准确估计了 `Tilt` 的绝对值（例如，真实值 `-20°`，估计值 `20°`），但在正负号上出现了混淆。
    -   **原因分析**: 这依然是由于我们使用的 `ts_physical_model` **过于简化和对称**所导致。在当前模型中，一个 `Tilt = τ` 的姿态与 `Tilt = -τ` 的姿态（例如，头朝上20度和头朝下20度），在计算其TS差异特征时会产生**完全相同**的一组声学指纹。因此，贝叶斯解算器无法区分这两种情况。在最终的热力图上，您会观察到两个概率峰值，它们在 `Yaw` 轴上位置相同，但在 `Tilt` 轴上位于 `±真实Tilt` 的位置。

## 4. 如何运行与后续步骤

-   **运行**: 在命令行中直接执行 `python bayesian_solver.py`。该脚本现在支持命令行参数，您可以轻松地为一次特定的模拟指定“真实”姿态。
    ```bash
    # 使用默认姿态 (Yaw=45, Tilt=-20) 运行
    python bayesian_solver.py

    # 指定一个新的“真实”姿态进行模拟
    python bayesian_solver.py --yaw 90 --tilt 0
    ```
-   **后续研究建议**:
    1.  **修改真实姿态**: 通过使用 `--yaw` 和 `--tilt` 命令行参数，或在无参数运行时修改脚本中的默认值，来测试模型在不同情况下的表现。
    2.  **引入非均匀先验**: 如果有先验知识（例如，鱿鱼更喜欢水平游动），可以修改 `run_bayesian_inversion` 函数中 `log_prior` 的计算方式，将先验知识融入模型。
    3.  **替换TS物理模型 (解决Tilt模糊性)**: 这是最关键的一步。将 `ts_physical_model` 函数替换为一个更真实的、**非对称的**TS模型（即能区分头部和腹部反射特性，使得 `TS(angle)` 不等于 `TS(-angle)`），将有望消除 `Tilt` 的正负号模糊性问题。
    5.  **更新和扩展经验TS模型数据**:
    *   **当前数据范围**: 目前我们使用的 `TS_interpolated_0p1kHz.nc` 文件中的测量数据涵盖了 **-60°到+20°** 的入射角范围。
    *   **数据补充与更新**: 如果您未来获得了更完整（例如补充了 `[-90°, -60°]` 和 `[+20°, +90°]` 范围的数据，使之覆盖整个 `[-90°, +90°]`）或更精确的TS测量数据，您只需用这些新数据更新 `TS_interpolated_0p1kHz.nc` 文件（请确保文件结构和格式与当前文件一致）。
    *   `bayesian_solver.py` 会自动使用更新后的数据重建经验TS模型和统计查找表，从而使反演模型保持最新和最精确。
    *   **重要性**: 补齐数据范围将使经验TS模型在整个姿态空间内都基于真实测量而非外插，这将显著提高模型的准确性，并有望最终解决 `Tilt` 方向的正负号模糊性问题。
    *   **频率依赖性**: 我们的分析 (`build_and_compare_ts_model.py`) 已经证明，TS模型是频率依赖的。因此，在处理真实世界的回波数据时，必须先确定信号的频率，并使用为该频率专门生成的查找表（LUT）进行反演。这可能意味着为每个关键频率都准备一个 `TS_interpolated_*.nc` 文件，并在 `bayesian_solver.py` 中选择对应的频率来构建经验模型。

## 附录二：如何快速测试反演算法

在耗费大量时间生成了核心的查找表 `ts_diff_empirical_lut.nc` 之后，我们往往希望能快速、反复地测试反演算法在不同姿态下的表现，而无需每次都重新生成LUT。为此，我们提供了一个专门的 `fast_inversion_tester.py` 脚本。

-   **目的**: 跳过耗时的模型构建和LUT生成阶段，直接加载已有的LUT文件，快速测试和验证贝叶斯**反演算法**本身的效果。
-   **工作流程**:
    1.  **加载LUT**: 脚本启动后，直接加载 `ts_diff_empirical_lut.nc` 文件。
    2.  **从LUT模拟观测**: 这是此脚本的关键。它并**不**调用底层的 `EmpiricalTSModel`，而是直接从LUT中为您想测试的姿态 `(Yaw, Tilt)` 提取其TS差异的统计特性（均值μ和标准差σ），然后从对应的正态分布 `N(μ, σ²)` 中随机采样，生成一组“模拟观测值”。这个过程非常迅速。
    3.  **执行反演与可视化**: 用这组模拟观测值，执行与 `bayesian_solver.py` 中完全相同的第三和第四阶段，即运行贝叶斯解算器并显示结果热力图。
-   **如何使用**:
    通过命令行参数方便地指定要测试的姿态。
    ```bash
    # 测试 Yaw=120°, Tilt=-14°
    python fast_inversion_tester.py --yaw 120 --tilt -14

    # 不提供参数则使用脚本内设定的默认值
    python fast_inversion_tester.py
    ```
-   **优势**: 您可以在几秒钟内就完成一次对任意姿态的反演测试，从而高效地探索模型的表现、边界和模糊性问题。

## 附录三：核心数学公式梳理

本部分将 `bayesian_solver.py` 脚本中的核心计算过程转化为数学公式，以便于理解和论文撰写。

### 1. 姿态与入射角定义

定义鱿鱼的姿态向量 $\vec{S}$ 和声学波束的指向向量 $\vec{B_i}$。

- 鱿鱼的姿态由方向角（Yaw, $\psi$）和倾斜角（Tilt, $\tau$）决定。其身体中轴线的单位向量 $\vec{S}$ 在三维空间中可以表示为：
  $$
  \vec{S} = (\cos\tau \cos\psi, \cos\tau \sin\psi, \sin\tau)
  $$

- 五个波束的中心轴单位向量 $\vec{B_i}$ (i $\in$ {North, South, West, East, Vertical}) 定义如下：
  $$
  \vec{B}_{North} = (0, 1, 0) \quad \vec{B}_{South} = (0, -1, 0) \\
  \vec{B}_{West} = (-1, 0, 0) \quad \vec{B}_{East} = (1, 0, 0) \\
  \vec{B}_{Vertical} = (0, 0, -1)
  $$

- 对于任意一个波束 $i$，其声学中心轴与鱿鱼身体中轴线之间的**入射角** $\alpha_i$ (Incidence Angle) 定义为：
  $$
  \alpha_i(\psi, \tau) = \arccos(\vec{S} \cdot \vec{B_i}) - 90^\circ
  $$
  这里的 $-90^\circ$ 是为了将角度范围从 $[0^\circ, 180^\circ]$ (向量夹角) 转换到 `[-90°, +90°]` (声学入射角，其中 $0^\circ$ 代表垂直入射)。

### 2. TS观测值正向模拟 (Forward Simulation)

正向模型的目标是模拟在给定姿态 $(\psi, \tau)$ 和体长 $L$ 的条件下，我们能够观测到的TS值。观测到的TS值包含多个随机因素。

- 对于波束 $i$，其最终模拟的TS值 $TS_i$ 由三部分组成：
  $$
  TS_i(\psi, \tau, L) = TS_{base}(\alpha_i') + \Delta TS_{len}(L) + \epsilon_{ts}
  $$
  其中：
  1.  **基础TS值** $TS_{base}(\alpha_i')$：
      -   首先，考虑波束宽度引入的角度不确定性，得到一个带有扰动的入射角 $\alpha_i'$：
          $$
          \alpha_i' = \alpha_i(\psi, \tau) + \epsilon_{beam}, \quad \epsilon_{beam} \sim \mathcal{N}(0, \sigma_{beam}^2)
          $$
          其中 $\sigma_{beam}$ 是波束不确定性的标准差。
      -   然后，通过经验TS模型（`EmpiricalTSModel` 类）查询得到基础TS值：
          $$
          TS_{base}(\alpha_i') = f_{empirical}(\alpha_i')
          $$

  2.  **体长贡献** $\Delta TS_{len}(L)$：
      -   相对于一个参考体长 $L_{ref}$，实际体长 $L$ 会导致TS值的偏移：
          $$
          \Delta TS_{len}(L) = 20 \log_{10} \left( \frac{L}{L_{ref}} \right)
          $$

  3.  **测量噪声** $\epsilon_{ts}$：
      -   模拟电子设备或环境引入的随机测量误差：
          $$
          \epsilon_{ts} \sim \mathcal{N}(0, \sigma_{ts}^2)
          $$

- **TS差异 (TS Difference)**：
  为了消除体长 $L$ 的影响，我们计算水平波束与垂直波束的TS差异 $\Delta TS_j$ ($j \in \{N-V, S-V, W-V, E-V\}$)：
  $$
  \Delta TS_j = TS_{horizontal} - TS_{Vertical}
  $$
  由于体长贡献项 $\Delta TS_{len}(L)$ 对所有波束是相同的，它在相减过程中被完全抵消。

- **统计查找表 (LUT) 的构建**：
  `generate_statistical_lut` 函数通过蒙特卡洛方法，对随机体长 $L$、角度扰动 $\epsilon_{beam}$ 和测量噪声 $\epsilon_{ts}$ 进行大量采样，从而估计出在每个给定姿态 $(\psi, \tau)$ 下，四个TS差异 $\Delta TS_j$ 的均值 $\mu_j(\psi, \tau)$ 和标准差 $\sigma_j(\psi, \tau)$。

### 3. 贝叶斯逆向解算 (Bayesian Inversion)

逆向解算的目标是，在给定一组TS差异观测值 $D = \{\Delta TS_{N-V}, \Delta TS_{S-V}, \Delta TS_{W-V}, \Delta TS_{E-V}\}$ 的条件下，推断出最可能的姿态 $(\psi, \tau)$。

- 根据贝叶斯定理，后验概率 $P((\psi, \tau) | D)$ 正比于似然度与先验概率的乘积：
  $$
  P((\psi, \tau) | D) \propto P(D | (\psi, \tau)) \times P(\psi, \tau)
  $$

- **似然度 (Likelihood)** $P(D | (\psi, \tau))$：
  -   似然度表示在假设姿态为 $(\psi, \tau)$ 的情况下，观测到数据 $D$ 的概率。
  -   我们假设四个TS差异的测量是相互独立的，并且每个都服从高斯分布（其均值和标准差已在LUT中预先计算）。因此，总似然度是各分量似然度的乘积：
      $$
      P(D | (\psi, \tau)) = \prod_{j} P(\Delta TS_j | (\psi, \tau)) = \prod_{j} \frac{1}{\sqrt{2\pi}\sigma_j(\psi, \tau)} \exp\left(-\frac{(\Delta TS_j - \mu_j(\psi, \tau))^2}{2\sigma_j^2(\psi, \tau)}\right)
      $$
  -   在实践中，为避免数值下溢并简化计算，我们通常使用对数似然度 (Log-Likelihood)：
      $$
      \log P(D | (\psi, \tau)) = \sum_{j} \left[ -\log(\sigma_j(\psi, \tau)) - \frac{(\Delta TS_j - \mu_j(\psi, \tau))^2}{2\sigma_j^2(\psi, \tau)} \right] - C
      $$
      其中 $C$ 是一个不依赖于姿态的常数，在后续计算中可以忽略。

- **先验概率 (Prior)** $P(\psi, \tau)$：
  -   先验概率代表了在获得任何观测数据之前，我们对姿态分布的已有认知。
  -   在默认情况下，我们使用**均匀先验 (Uniform Prior)**，即认为所有姿态都是等可能的：
      $$
      P(\psi, \tau) = \text{Constant}
      $$
      在这种情况下，后验概率将完全由似然度决定。

- **后验概率 (Posterior)**：
  -   结合对数似然度和对数先验（对于均匀先验，其对数为常数），我们得到对数后验：
      $$
      \log P((\psi, \tau) | D) \approx \log P(D | (\psi, \tau)) + \text{Constant}
      $$
  -   为了得到一个归一化的概率分布，我们对所有可能的姿态 $(\psi_k, \tau_k)$ 进行计算，并通过Softmax函数进行归一化：
      $$
      P((\psi_k, \tau_k) | D) = \frac{\exp(\log P(D | (\psi_k, \tau_k)))}{\sum_{m} \exp(\log P(D | (\psi_m, \tau_m)))}
      $$
  -   最终，具有最大后验概率的姿态 $(\hat{\psi}, \hat{\tau})$ 就是我们对真实姿态的最佳估计：
      $$
      (\hat{\psi}, \hat{\tau}) = \underset{(\psi, \tau)}{\arg\max} \, P((\psi, \tau) | D)
      $$
